# jvm内存回收终极奥义：垃圾收集算法

## 前言：

上一篇文章我们用尽废话说了说一个对象是如何被判定为死亡的，并提到java内存回收局经历过多年的发展，发明出来一款**java验死仪**，从而一举解决了普通java对象，验死难，回收难的重大问题，受到了java虚拟机总局各位领导的一致表扬。咳咳，跑题了，当然，仅仅是有这一项神器是不足以java内存回收局荣获每年的最佳组织奖的，jvm为了更方便的进行内存回收，还发明出了多达7种java垃圾回收仪，它们被统称为:

垃圾对象回收仪！（哆啦A梦音效）

本着“**回收垃圾，掌握核心科技**”的信念，垃圾对象回收仪同样也是由四大算法为原理驱动的，它们分别是：

**标记-清除算法、复制算法、标记整理算法，分代收集算法。**



## 基本概念：

java中分代垃圾收集算法将java堆按存活时间分为两个区域，一个用来存放新生代对象，一个用来存放老生代对象。

新生代：新生代就容易理解多了，我还专门编了一个童谣(滑稽)：

​                新生代，新生代

​                对象小，死的快

你有毒吧。

老生代：特指那些活得时间比较长的对象。

## 标记-清除算法（Mark-Sweep）：

标记-清除算法，是所有垃圾收集算法中最基础的一个，在别的垃圾收集算法面前就是个弟弟。长江后浪推前浪吗，标记清除算法再沙滩上，和我们大多数发展规律一样，后面的算法很多都是基于标记-清除算法改进而来的。

标记-清除算法，就是一个先标记然后再清除的算法（你这不是脱了裤子放..吗），具体的回收流程是这样的：

- 标记出所有需要回收的对象
- 标记完之后统一回收这些被标记的对象

没了，要不说它简单呢。

但是在实现简单的同时也同时带来了很多额外的问题，其中主要集中在两点：

- 首先首当其冲的就是效率问题，本身标记清除这两个过程都不太高，因为你要找到一个个对象，给他们盖上章，然后再一个个去清除，肯定没有一锅端了快。
- 第二个就是空间利用问题了，因为在内存中那些需要被回收的对象不是一个挨着一个那么排着队等你回收的，而是分散在内存各处，清除的时候Java虚拟机要一个地儿一个地儿的跑，然后再去回收，因为对象是分散在各处的，所以我们回收完就容易出现，这一小块内存是空的，那一小块内存是空的，这么下去会导致内存中都是一小块一小块的内存，当一个比较大的对象需要分配内存时，系统找不到这么大块的连续内存了，找不到系统很着急啊，于是就不得不提前触发另外一次垃圾收集动作了。

图大概是长这个样子，来自掘金(刘望舒)大佬的图：

![img](https://user-gold-cdn.xitu.io/2017/5/25/bf02ac56d921a4174192c3b64ba2d885?imageView2/0/w/1280/h/960/ignore-error/1)

这样结合文字再看就是不是就容易理解多了。

## 复制算法（Copying）：

标记-清除算法出来之后，处女座看不下去了。

处女座：你瞧瞧你回收的那都是什么玩意儿，回收完那内存乱的，哎呀妈呀我都没法看，就不能整理一下吗，一家人整整齐齐的多好。

于是复制算法应运而生了。（纯属瞎扯，切勿当真）

这个算法呢，将内存容量按照容量分为两个大小相等的两块，每次呢，我只用一块，把另一块先留着，当其中一块的内存用完的时候，就把还活着的对象复制到另外一块上去，然后将使用过的这块直接一次清完，**简单粗暴，运行高效**，因为是整个一大块内存一次回收，所以也不存在什么内存碎片的问题了，但是天下没有免费的午餐，这么做也是要付出一定的代价的，那就是原本我100M的内存，现在一次只让我用50M。

**这就好像你有一整包辣条，一次却只让你吃半袋，想想就难受。**

复制算法呢，一般主要用来回收新生代的对象，为什么？因为**新生代，死的快**。

因为新生代的对象很快都会被回收掉，所以一般我们也不按照一比一那么分，在 hotspot虚拟机中，将内存分成三块，一块是比较大的Eden(伊甸园),和两块较小的Survivor(幸存者)空间，每次使用一块Eden和一块Survivor，当需要回收时，将这两块内存中存活的对象一次性复制到另一块survivor中，然后直接清理掉刚才用过的eden和survivor空间。在 hotspot虚拟机中，Eden和Survivor的比例默认为8：1，后期可以通过修改虚拟机参数来修改Eden和Survivor之间的比例，经过我细致入微头脑风暴般的计算（别人算的好吧），在 hotspot虚拟机中采用这种比例的复制算法在新生代中内存浪费率只有10%，的确要远远低于上面的百分之50.

等等，你不是说survivor空间较小吗，两块内存存活的对象都复制到一块survivor上，万一survivor装不下咋弄。难住你了吧，我看你怎么办。

**我没有，我不能借吗**，jvm引入了分配担保这个概念，当survivor空间不够时，这些对象将通过分配担保机制直接进入老年代。至于分配担保具体是怎么玩的，大家可以查阅相关资料看下哈，我打字打的手疼（小声逼逼，你也没把握讲清楚好吧，嘘）。

那复制算法既然表现这么香，那为什么不能用来回收老年代区域呢？

你想想，老年代是什么，java虚拟机中的长寿村，平常一般都不死，你搞个复制算法过去一看

尼玛，都还活着呢

然后一个一个把一大堆活着的老对象复制过去，更别说极端条件下一个也没死的情况了。

对了，复制算法的图如下：

![img](https://user-gold-cdn.xitu.io/2017/5/25/1b99da204cf8c52fa9b1cfbcdd449852?imageView2/0/w/1280/h/960/ignore-error/1)

## 标记-整理算法（Mark-Compact）：

难道针对老年代就没什么办法了，标题都写了，那肯定就是有的，那就是标记-整理算法，我又把它称为“**弟弟们都往边上靠靠”**算法。

标记-整理算法特别适合老年代，为什么呢，因为不叫标记 -复制啊，标记-整理算法其实和标记-清除算法原理差不多，只不过不是直接对内存整理，而是让**弟弟们都往边上靠靠**，即让存活的老年代对象都向一侧移动，等这些弟弟都挨着挪到一块儿之后，直接把其他地方的内存直接清理掉。

![img](https://user-gold-cdn.xitu.io/2017/5/25/4d2c971fdc57b1ada9a2a1a1cf17d764?imageView2/0/w/1280/h/960/ignore-error/1)



## 分代收集算法：

分代算法没什么新的东西，前面基本概念那一小节其实就是说的这个算法，分代收集算法根据对象的存活周期的不同把对象划分为新生代和老年代两种，分代收集算法的好处就是实现了对症下药，使得我们可以根据不同的对象采用不同的垃圾收集算法，比如新生代，死的快(又来)，就用复制算法，老生代的话就用标记-整理算法，或者标记-清除算法来回收。

没了

这个真没图

## 总结：

本篇文章我们较为细致的说了我们垃圾收集算法四小龙，也举了比如辣条的实例帮助大家加深理解。四种垃圾回收算法各有优劣，并由此衍生出来7中常用的垃圾收集器，关于垃圾收集器的文章呢，我们后期再更新。

可以多点更新吗？

不托更，你关注我啊。

我关注你

好

我是韩数，我们下篇文章再见。

















